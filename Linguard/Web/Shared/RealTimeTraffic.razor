@using Linguard.Core.Models
@using Linguard.Core.Models.Wireguard
@using Linguard.Web.Utils
@using ByteSizeLib
@using Linguard.Core.Configuration
@using Linguard.Core.Managers
@using Linguard.Core.Services

<div class="row">
    <!-- Real time -->
    <div class="col-md-6 mt-2">
        <RadzenCard>
            <h3>Real time</h3>
            @if (_realTimeTraffic == default || _realTimeChartData.All(d => d.Value == default)) {
                <p>There is no data yet.</p>
            }
            else {
                <RadzenChart>
                    <RadzenDonutSeries Data="@_realTimeChartData"
                                       CategoryProperty="Key" ValueProperty="Value.Bytes">
                        <TooltipTemplate Context="data">
                            <strong>@data.ToString()</strong>
                        </TooltipTemplate>
                    </RadzenDonutSeries>
                </RadzenChart>
            }
        </RadzenCard>
    </div>
    <!-- History -->
    <div class="col-md-6 mt-2">
        <RadzenCard>
            <h3>History</h3>
            @if (!Configuration.Traffic.Enabled) {
                <p>
                    It looks like traffic data storage is disabled.
                    <a href="/settings">Enable it</a> to get more statistics.
                </p>
                return;
            }
            <!-- TODO -->
            <p>There is no data yet.</p>
        </RadzenCard>
    </div>
</div>

@inject IConfigurationManager _configurationManager
@inject IWireguardService _wireguardService

@code {
    IConfiguration Configuration => _configurationManager.Configuration;
    
    [Parameter]
    public IWireguardPeer Peer { get; set; }

    TrafficData? _realTimeTraffic;

    IEnumerable<ChartTrafficData> _realTimeChartData => new List<ChartTrafficData> {
        new() {
            Key = "Received",
            Value = _realTimeTraffic?.ReceivedData ?? ByteSize.FromBytes(0)
        },
        new() {
            Key = "Transmitted",
            Value = _realTimeTraffic?.SentData ?? ByteSize.FromBytes(0)
        }
    };

    protected override void OnInitialized() {
        base.OnInitialized();
        _realTimeTraffic = GetRealTimeTraffic();
    }

    private TrafficData? GetRealTimeTraffic() {
        switch (Peer) {
            case Client client:
                return _wireguardService.GetTrafficData(client);
            case Interface iface:
                return _wireguardService.GetTrafficData(iface).SingleOrDefault(e => e.Peer is Interface);
            default:
                throw new NotSupportedException($"Peer type not supported: {Peer.GetType()}");
        }
    }

}